name: Generate Project Roadmap from README

on:
  workflow_dispatch:
    inputs:
      create_issues:
        description: 'Issues aus Roadmap erstellen?'
        required: false
        default: 'true'
        type: boolean

permissions:
  contents: write
  issues: write

jobs:
  generate-roadmap:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.PTA_TOKEN }}

    - name: Read README.md Content
      id: read-readme
      run: |
        if [ -f "README.md" ]; then
          echo "ğŸ“– README.md gefunden, analysiere Projekt-Konzept..."
          README_CONTENT=$(cat README.md)
          echo "âœ… README.md gelesen: $(echo "$README_CONTENT" | wc -l) Zeilen"
          
          # Base64 encode fÃ¼r sichere Ãœbertragung
          README_BASE64=$(echo "$README_CONTENT" | base64 -w 0)
          echo "readme-content=$README_BASE64" >> $GITHUB_OUTPUT
          
          # Projekt-Typ erkennen
          if echo "$README_CONTENT" | grep -i "fastapi\|python\|react" >/dev/null; then
            echo "ğŸ Python/React Projekt erkannt"
          elif echo "$README_CONTENT" | grep -i "node\|express\|javascript" >/dev/null; then
            echo "ğŸ“¦ Node.js Projekt erkannt"
          else
            echo "ğŸ“‹ Software-Projekt erkannt"
          fi
        else
          echo "âŒ README.md nicht gefunden!"
          exit 1
        fi

    - name: Generate Roadmap with AI (Using Cybersecurity Template Style)
      id: generate-roadmap
      env:
        OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API }}
      run: |
        README_CONTENT=$(echo "${{ steps.read-readme.outputs.readme-content }}" | base64 -d)
        
        # AI Models
        MODELS=("meta-llama/llama-3.2-3b-instruct:free" "mistralai/mistral-7b-instruct:free" "qwen/qwen-2-7b-instruct:free")
        ROADMAP_CONTENT=""
        
        for MODEL in "${MODELS[@]}"; do
          echo "ğŸ¤– Generiere Roadmap mit: $MODEL"
          
          # Prompt basiert auf Cybersecurity-Template aber fÃ¼r beliebiges Projekt
          PROMPT_JSON=$(python3 -c "
        import json
        
        readme_content = '''$README_CONTENT'''
        
        system_prompt = 'Du bist ein Senior Software Architect und DevOps Expert. Analysiere Software-Konzepte und erstelle detaillierte Entwicklungs-Roadmaps.\\n\\nKRITISCHES FORMAT (EXAKT befolgen):\\n**PHASE X: Phasenname\\n* [ ] Task Name\\n* Detaillierte technische Beschreibung mit konkreten Befehlen, Tools und Implementierungsdetails\\n\\nEXAMPLE:\\n**PHASE 1: Foundation Setup\\n* [ ] Repository Setup\\n* Erstelle Git Repository mit .gitignore fÃ¼r das Projekt. Setup Branching-Strategie (main/develop/feature). Konfiguriere GitHub Actions fÃ¼r CI/CD Pipeline mit automatischen Tests.\\n\\n* [ ] Development Environment\\n* Setup lokale Entwicklungsumgebung: Python Virtual Environment, installiere Requirements, setup Database Connection, konfiguriere Environment Variables (.env file).\\n\\nANFORDERUNGEN:\\n- Technische Details mit konkreten Befehlen\\n- Moderne Best Practices (Docker, Testing, CI/CD)\\n- Security und Performance Aspekte\\n- VollstÃ¤ndige Implementierungsschritte\\n- Tools und Dependencies spezifizieren'
        
        user_prompt = f'Analysiere dieses Software-Konzept und erstelle eine DETAILLIERTE Entwicklungs-Roadmap:\\n\\n{readme_content}\\n\\nErstelle eine vollstÃ¤ndige Roadmap mit allen technischen Schritten zur Umsetzung. Jeder Task braucht:\\n1. Klaren Titel\\n2. Detaillierte Beschreibung mit konkreten Befehlen\\n3. Tools und Technologies\\n4. Implementierungsdetails\\n\\nPHASEN sollten logisch aufeinander aufbauen:\\n- Foundation (Setup, Infrastructure)\\n- Backend Development\\n- Frontend Development\\n- Testing & Quality\\n- Deployment & Operations\\n- Advanced Features\\n\\nFormat: **PHASE X: Name\\\\n* [ ] Task\\\\n* Beschreibung\\\\n\\\\n'
        
        prompt_data = {
            'model': '$MODEL',
            'messages': [
                {
                    'role': 'system',
                    'content': system_prompt
                },
                {
                    'role': 'user', 
                    'content': user_prompt
                }
            ],
            'temperature': 0.3,
            'max_tokens': 3500
        }
        
        print(json.dumps(prompt_data, ensure_ascii=False))
        ")
          
          echo "$PROMPT_JSON" > ai_prompt.json
          
          # Validiere JSON
          if ! jq empty ai_prompt.json 2>/dev/null; then
            echo "âŒ JSON ungÃ¼ltig fÃ¼r $MODEL"
            continue
          fi
          
          # API Call
          AI_RESPONSE=$(curl -s -X POST "https://openrouter.ai/api/v1/chat/completions" \
            -H "Authorization: Bearer $OPENROUTER_API_KEY" \
            -H "Content-Type: application/json" \
            -H "HTTP-Referer: https://github.com/${{ github.repository }}" \
            -H "X-Title: Project Roadmap Generator" \
            -d @ai_prompt.json)
          
          echo "ğŸ” AI Response Status: $(echo "$AI_RESPONSE" | jq -r '.choices[0].message.content // .error.message // "Unbekannt"' | head -1)"
          
          # PrÃ¼fe auf Erfolg
          if echo "$AI_RESPONSE" | jq -e '.error' >/dev/null 2>&1; then
            ERROR_MSG=$(echo "$AI_RESPONSE" | jq -r '.error.message // "Unbekannter Fehler"')
            echo "âŒ Model $MODEL fehlgeschlagen: $ERROR_MSG"
            continue
          else
            ROADMAP_CONTENT=$(echo "$AI_RESPONSE" | jq -r '.choices[0].message.content' 2>/dev/null || echo "")
            if [ -n "$ROADMAP_CONTENT" ] && [ "$ROADMAP_CONTENT" != "null" ]; then
              echo "âœ… Roadmap erfolgreich generiert mit $MODEL"
              break
            fi
          fi
        done
        
        # Fallback mit Template-basierter Roadmap
        if [ -z "$ROADMAP_CONTENT" ] || [ "$ROADMAP_CONTENT" = "null" ]; then
          echo "âš ï¸ AI fehlgeschlagen, erstelle Template-basierte Roadmap..."
          
          # Analysiere README fÃ¼r Projekt-Typ
          if echo "$README_CONTENT" | grep -i "fastapi\|python\|django" >/dev/null; then
            TECH_STACK="Python/FastAPI"
            BACKEND_SETUP="FastAPI, SQLAlchemy, Alembic Migrations, PostgreSQL"
          elif echo "$README_CONTENT" | grep -i "node\|express\|javascript" >/dev/null; then
            TECH_STACK="Node.js/Express"
            BACKEND_SETUP="Express.js, Sequelize ORM, MongoDB/PostgreSQL"
          elif echo "$README_CONTENT" | grep -i "react\|vue\|angular" >/dev/null; then
            TECH_STACK="Frontend Framework"
            BACKEND_SETUP="REST API Backend"
          else
            TECH_STACK="Web Application"
            BACKEND_SETUP="Backend Framework"
          fi
          
          ROADMAP_CONTENT="# Software Development Roadmap
Generated from README.md Analysis - Tech Stack: $TECH_STACK

## PHASE 1: Foundation Setup
* [ ] Repository Setup
* Erstelle Git Repository mit .gitignore fÃ¼r $TECH_STACK. Setup Branching-Strategie (main/develop/feature). Konfiguriere GitHub Actions fÃ¼r CI/CD Pipeline mit automatischen Tests und Deployments.

* [ ] Development Environment  
* Setup lokale Entwicklungsumgebung: Virtual Environment, Package Manager, Database Setup, Environment Variables (.env), lokale Development Server Konfiguration.

* [ ] Database Setup
* Installiere und konfiguriere Database (PostgreSQL empfohlen). Erstelle Development/Testing/Production Schemas. Setup Migrations-System fÃ¼r Schema-Changes.

* [ ] Docker Configuration
* Erstelle Dockerfile fÃ¼r Application. Setup Docker Compose fÃ¼r Development (App + Database + Redis). Konfiguriere Multi-Stage Builds fÃ¼r Production.

## PHASE 2: Backend Development
* [ ] API Framework Setup
* Implementiere $BACKEND_SETUP. Setup Routing-System, Middleware fÃ¼r CORS/Auth/Logging, Request/Response Validation, Error Handling.

* [ ] Database Models
* Entwickle Data Models/Entities basierend auf README-Anforderungen. Implementiere Relationships, Constraints, Indexes. Setup ORM Mappings.

* [ ] Authentication System
* Implementiere User Registration/Login. JWT Token System, Password Hashing (bcrypt), Role-based Access Control (RBAC), Session Management.

* [ ] Core API Endpoints
* Entwickle REST API Endpoints fÃ¼r Hauptfunktionen. Implementiere CRUD Operations, Input Validation, Pagination, Search/Filter Funktionen.

## PHASE 3: Frontend Development
* [ ] Frontend Framework Setup
* Setup React/Vue/Angular Application. Konfiguriere TypeScript, Routing (React Router), State Management (Redux/Vuex), Build Tools (Vite/Webpack).

* [ ] UI Component Library
* Implementiere Design System mit wiederverwendbaren Components. Setup CSS Framework (Tailwind/Material-UI), Responsive Design, Theme Support.

* [ ] API Integration
* Implementiere HTTP Client fÃ¼r Backend Communication. Setup Axios/Fetch with Interceptors, Error Handling, Loading States, Caching.

* [ ] User Interface
* Entwickle User Interface basierend auf README-Anforderungen. Implementiere Forms, Navigation, Dashboard Views, Mobile Responsive Design.

## PHASE 4: Testing & Quality
* [ ] Unit Testing
* Schreibe Unit Tests fÃ¼r Backend (pytest/jest). Test Coverage >90%, Mock Dependencies, Database Tests mit Test-DB.

* [ ] Integration Testing  
* Implementiere API Integration Tests. Test komplette Request/Response Flows, Database Interactions, Authentication Flows.

* [ ] End-to-End Testing
* Setup E2E Tests mit Playwright/Cypress. Test kritische User Journeys, Cross-Browser Testing, Mobile Testing.

* [ ] Code Quality
* Setup ESLint/Prettier/Black fÃ¼r Code Formatting. Pre-commit Hooks, Static Code Analysis, Security Scanning (Bandit/ESLint Security).

## PHASE 5: Deployment & Operations
* [ ] Production Infrastructure
* Setup Production Server (Ubuntu 24 LTS). Installiere NGINX als Reverse Proxy, SSL Certificates (Let's Encrypt), Firewall Configuration.

* [ ] CI/CD Pipeline
* Implementiere GitHub Actions Workflows. Automated Testing, Building, Docker Image Push, Deployment to Production, Rollback Strategies.

* [ ] Monitoring & Logging
* Setup Application Monitoring (Prometheus/Grafana). Error Tracking (Sentry), Log Aggregation (ELK Stack), Health Checks, Alerting.

* [ ] Backup & Security
* Implementiere Database Backups (automatisch). Security Headers, HTTPS Enforcement, Rate Limiting, Input Sanitization, Dependency Updates.

## PHASE 6: Advanced Features
* [ ] Performance Optimization
* Database Query Optimization, Caching (Redis), CDN Integration, Image Optimization, Lazy Loading, Code Splitting.

* [ ] Security Hardening
* Security Audit, Penetration Testing, OWASP Top 10 Compliance, Data Encryption, Secure Headers, CSP Implementation.

* [ ] Scalability
* Load Testing, Database Scaling, Container Orchestration (Kubernetes), Auto-scaling, Performance Monitoring.

* [ ] Business Features
* User Analytics, Email Notifications, Export Functions, API Documentation (Swagger), Admin Dashboard."
        fi
        
        # Speichere Roadmap
        echo "$ROADMAP_CONTENT" > roadmap.md
        echo "roadmap-content=$ROADMAP_CONTENT" >> $GITHUB_OUTPUT
        echo "ğŸ¯ Roadmap generiert und in roadmap.md gespeichert"

    - name: Commit Roadmap
      run: |
        git config --global user.name 'github-actions[bot]'
        git config --global user.email 'github-actions[bot]@users.noreply.github.com'
        git add roadmap.md
        if git diff --staged --quiet; then
          echo "ğŸ”„ Keine Ã„nderungen an roadmap.md"
        else
          git commit -m "ğŸ—ºï¸ Generate detailed project roadmap from README.md
          
          - AI-generated development roadmap
          - Technical implementation steps  
          - Based on README.md project analysis
          - Ready for issue creation
          - Generated: $(date)"
          git push
          echo "âœ… Roadmap committed und gepusht"
        fi

    - name: Extract Tasks and Create Issues
      if: github.event.inputs.create_issues == 'true'
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.PTA_TOKEN }}
        script: |
          const roadmapContent = `${{ steps.generate-roadmap.outputs.roadmap-content }}`;
          
          console.log('ğŸ” Parsing komplette Roadmap fÃ¼r Issue-Erstellung...');
          
          // Parse Roadmap fÃ¼r ALLE Tasks
          const lines = roadmapContent.split('\n');
          let currentPhase = '';
          let issues = [];
          let i = 0;
          
          while (i < lines.length) {
            const line = lines[i].trim();
            
            // Erkenne Phase
            if (line.startsWith('## PHASE')) {
              currentPhase = line.replace(/^## /, '').trim();
              console.log(`ğŸ“‹ Phase gefunden: ${currentPhase}`);
            }
            
            // Erkenne Task
            else if (line.startsWith('* [ ]')) {
              const taskTitle = line.replace('* [ ]', '').trim();
              let taskDescription = '';
              
              // Sammle vollstÃ¤ndige Beschreibung
              i++;
              while (i < lines.length) {
                const nextLine = lines[i].trim();
                if (nextLine.startsWith('* [ ]') || nextLine.startsWith('## PHASE')) {
                  i--; // Gehe zurÃ¼ck
                  break;
                }
                if (nextLine.startsWith('*') && !nextLine.startsWith('* [ ]')) {
                  taskDescription += nextLine.replace(/^\*/, '').trim() + '\n';
                } else if (nextLine.length > 0 && !nextLine.startsWith('#')) {
                  taskDescription += nextLine + '\n';
                }
                i++;
              }
              
              if (taskTitle && taskDescription.trim()) {
                const phaseLabel = currentPhase.toLowerCase().replace(/[^a-z0-9]/g, '-').replace(/^phase-\d+-/, '');
                issues.push({
                  title: `${taskTitle}`,
                  description: taskDescription.trim(),
                  phase: currentPhase,
                  labels: ['enhancement', 'roadmap', phaseLabel]
                });
                console.log(`âœ… Task hinzugefÃ¼gt: ${taskTitle}`);
              }
            }
            i++;
          }
          
          console.log(`ğŸ¯ Insgesamt ${issues.length} Tasks aus Roadmap extrahiert`);
          console.log(`ğŸ“Š Erstelle ALLE ${issues.length} Issues...`);
          
          // Erstelle ALLE Issues aus der Roadmap
          let createdCount = 0;
          let errorCount = 0;
          
          for (let index = 0; index < issues.length; index++) {
            const issue = issues[index];
            try {
              const issueBody = `## ğŸ“‹ ${issue.phase}

${issue.description}

## âœ… Definition of Done
- [ ] Implementierung abgeschlossen  
- [ ] Tests geschrieben und bestanden
- [ ] Code-Review durchgefÃ¼hrt
- [ ] Dokumentation aktualisiert
- [ ] Ready for Production

## ğŸ”— Roadmap
Diese Aufgabe ist Teil der [Project Roadmap](./roadmap.md)  
**Task ${index + 1} von ${issues.length}**

---
*Auto-generiert aus README.md Analysis*`;
              
              const { data: createdIssue } = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: issue.title,
                body: issueBody,
                labels: issue.labels,
                assignees: []
              });
              
              console.log(`âœ… Issue #${createdIssue.number}: ${issue.title}`);
              createdCount++;
              
              // Moderate Pause um GitHub API nicht zu Ã¼berlasten
              if (index < issues.length - 1) { // Keine Pause beim letzten Issue
                await new Promise(resolve => setTimeout(resolve, 1000)); // 1 Sekunde
              }
              
            } catch (error) {
              console.log(`âŒ Issue Creation Error fÃ¼r "${issue.title}": ${error.message}`);
              errorCount++;
              
              // Bei Rate-Limit oder anderen API-Fehlern, lÃ¤ngere Pause und weiter versuchen
              if (error.message.includes('rate') || error.message.includes('limit')) {
                console.log('â±ï¸ Rate-Limit erreicht, warte 10 Sekunden...');
                await new Promise(resolve => setTimeout(resolve, 10000));
              } else {
                // Bei anderen Fehlern kurz warten und weiter
                await new Promise(resolve => setTimeout(resolve, 2000));
              }
            }
          }
          
          console.log(`ğŸ‰ Issue Creation abgeschlossen!`);
          console.log(`âœ… Erfolgreich erstellt: ${createdCount}`);
          console.log(`âŒ Fehler: ${errorCount}`);
          console.log(`ğŸ“Š Total: ${issues.length} Tasks aus Roadmap`);
          
          return { created: createdCount, errors: errorCount, total: issues.length };

    - name: Create Summary Issue
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.PTA_TOKEN }}
        script: |
          const { data: summaryIssue } = await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: 'ğŸ—ºï¸ Project Roadmap Generated from README.md',
            body: `## ğŸ‰ Development Roadmap erstellt!

Eine detaillierte Entwicklungs-Roadmap wurde aus der **README.md** generiert:

ğŸ“‹ **[roadmap.md](./roadmap.md)** - VollstÃ¤ndige Development Roadmap

## ğŸš€ NÃ¤chste Schritte

1. **Review**: ÃœberprÃ¼fe die generierte Roadmap
2. **Customize**: Passe Tasks an deine spezifischen Anforderungen an  
3. **Development**: Starte mit den Foundation Tasks
4. **Issues**: Alle Tasks wurden als Issues erstellt (Label: \`roadmap\`)

## ğŸ“Š Generation Info
- **Quelle**: README.md Analysis
- **AI Model**: Multiple Fallback Models (OpenRouter)
- **Format**: Cybersecurity Platform Template Style
- **Issues**: ${{ github.event.inputs.create_issues == 'true' && 'Alle Tasks als Issues erstellt' || 'Keine Issues erstellt' }}
- **Generated**:
